using System.Collections.Generic;
using UnityEngine;

namespace MBaske.Sensors.Grid
{
    /// <summary>
    /// A <see cref="DetectionResult"/> is generated by an
    /// <see cref="IDetector"/> and encoded by an <see cref="IEncoder"/>.
    /// </summary>
    public class DetectionResult
    {
        /// <summary>
        /// Wrapper for a <see cref="IDetectable"/> object and its  
        /// associated normalized points list. 
        /// Note that this refers to any object implementing 
        /// <see cref="IDetectable"/>. It is not to be confused 
        /// with <see cref="DetectableGameObject"/> which is a 
        /// specific implementation of <see cref="IDetectable"/>.
        /// </summary>
        public class Item
        {
            /// <summary>
            /// Detectable object.
            /// </summary>
            public IDetectable Detectable;

            /// <summary>
            /// List of normalized points, 0/0/0 to 1/1/1.
            /// Will be converted to grid positions by <see cref="IEncoder"/>.
            /// </summary>
            public List<Vector3> NormPoints = new List<Vector3>();

            /// <summary>
            /// Whether this <see cref="Item"/> contains any points.
            /// </summary>
            public bool HasPoints => NormPoints.Count > 0;
        }

        /// <summary>
        /// List of detectable tags.
        /// </summary>
        public IList<string> DetectableTags { get; private set; }

        private readonly Stack<Item> m_ItemPool;
        private readonly IList<IDetectable> m_Detectables;
        private readonly IDictionary<string, IList<Item>> m_ItemsByTag;

        /// <summary>
        /// Creates a <see cref="DetectionResult"/> instance.
        /// </summary>
        /// <param name="detectableTags">List of detectable tags</param>
        /// <param name="initCapacity">Initial capacity</param>
        public DetectionResult(IList<string> detectableTags, int initCapacity)
        {
            DetectableTags = new List<string>(detectableTags);
            int n = DetectableTags.Count;

            m_Detectables = new List<IDetectable>(initCapacity);
            m_ItemsByTag = new Dictionary<string, IList<Item>>(n);
            m_ItemPool = new Stack<Item>(initCapacity);

            for (int i = 0; i < n; i++)
            {
                m_ItemsByTag.Add(DetectableTags[i], new List<Item>(initCapacity));
            }
        }

        /// <summary>
        /// Clears the <see cref="DetectionResult"/>.
        /// </summary>
        public void Clear()
        {
            m_Detectables.Clear();

            foreach (var list in m_ItemsByTag.Values)
            {
                foreach (var item in list)
                {
                    item.NormPoints.Clear();
                    m_ItemPool.Push(item);
                }
                list.Clear();
            }
        }

        /// <summary>
        /// Adds an <see cref="IDetectable"/> and its associated normalized points.
        /// </summary>
        /// <param name="detectable">Detectable object</param>
        /// <param name="normPoints">Normalized points list</param>
        public void Add(IDetectable detectable, IList<Vector3> normPoints)
        {
            Item item = m_ItemPool.Count > 0 ? m_ItemPool.Pop() : new Item();
            item.Detectable = detectable;
            item.NormPoints.AddRange(normPoints);
            m_ItemsByTag[detectable.Tag].Add(item);
            m_Detectables.Add(detectable);
        }

        /// <summary>
        /// Tries to retrieve <see cref="Item"/> instances associated
        /// with a specific tag.
        /// </summary>
        /// <param name="tag">The specified tag</param>
        /// <param name="items">List of items (output)</param>
        /// <returns>Whether any items were found</returns>
        public bool TryGetItems(string tag, out IList<Item> items)
        {
            if (m_ItemsByTag.TryGetValue(tag, out items) && items.Count > 0)
            {
                return true;
            }

            items = null;
            return false;
        }

        /// <summary>
        /// Whether the <see cref="DetectionResult"/> contains 
        /// a specific <see cref="IDetectable"/> object.
        /// </summary>
        /// <param name="detectable">Detectable object</param>
        /// <returns>True if <see cref="IDetectable"/> was found</returns>
        public bool Contains(IDetectable detectable)
        {
            return m_Detectables.Contains(detectable);
        }

        /// <summary>
        /// Returns the <see cref="Item"/> instance count associated
        /// with a specific tag.
        /// </summary>
        /// <param name="tag">The specified tag</param>
        /// <returns>Number of items</returns>
        public int Count(string tag)
        {
            if (m_ItemsByTag.TryGetValue(tag, out IList<Item> items))
            {
                return items.Count;
            }

            return 0;
        }

        /// <summary>
        /// Returns the total <see cref="Item"/> instance count.
        /// </summary>
        /// <returns>Number of items</returns>
        public int Count()
        {
            int sum = 0;
            foreach (var list in m_ItemsByTag.Values)
            {
                sum += list.Count;
            }

            return sum;
        }
    }
}